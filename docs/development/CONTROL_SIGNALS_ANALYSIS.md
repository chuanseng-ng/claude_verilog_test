# Control Signal Analysis for rv32i_decode.sv

## Overview

This document analyzes additional control signals that may be needed for the RV32I decoder beyond what's in the EXAMPLE decoder.

## Currently Proposed Signals (in EXAMPLE)

| Signal | Width | Purpose |
| :----: | :---: | :-----: |
| `rs1`, `rs2`, `rd` | 5 bits each | Register addresses |
| `alu_op` | 4 bits | ALU operation selection |
| `alu_src_a` | 1 bit | ALU input A mux (rs1 vs PC) |
| `alu_src_b` | 1 bit | ALU input B mux (rs2 vs imm) |
| `imm_fmt` | 3 bits | Immediate format for generator |
| `reg_wr_en` | 1 bit | Register write enable |
| `mem_rd`, `mem_wr` | 1 bit each | Memory read/write enables |
| `mem_size` | 3 bits | Memory access size |
| `mem_unsigned` | 1 bit | Unsigned load flag |
| `branch` | 1 bit | Branch instruction flag |
| `branch_op` | 3 bits | Branch operation type |
| `jump` | 1 bit | Jump instruction flag |
| `jalr` | 1 bit | JALR vs JAL |
| `illegal` | 1 bit | Illegal instruction flag |

## Potentially Missing Signals

### 1. `mem_to_reg` (Write-Back Mux Control)

**Purpose**: Selects the source for register writeback value

**Encoding** (proposed):

- `2'b00` = ALU result
- `2'b01` = Memory read data (for loads)
- `2'b10` = PC + 4 (for JAL/JALR)
- `2'b11` = Immediate (for LUI - may not be needed if ALU can pass through)

**Importance**: ⭐⭐⭐ **CRITICAL**

**Why it's critical**:

- Load instructions need to write memory data to register, not ALU result
- JAL/JALR need to write PC+4 to link register
- Without this, all register writes would get ALU result

**Example usage**:

```systemverilog
// In writeback stage
always_comb begin
  case (mem_to_reg)
    2'b00: reg_wr_data = alu_result;
    2'b01: reg_wr_data = mem_read_data;
    2'b10: reg_wr_data = pc_plus_4;
    2'b11: reg_wr_data = immediate;
  endcase
end
```

**Instructions that need it**:

- `mem_to_reg = 2'b01`: LB, LH, LW, LBU, LHU (all loads)
- `mem_to_reg = 2'b10`: JAL, JALR
- `mem_to_reg = 2'b00`: All ALU operations (default)
- `mem_to_reg = 2'b11`: LUI (if not using ALU passthrough)

---

### 2. `pc_wr_en` (Program Counter Write Enable)

**Purpose**: Controls when the PC register is updated

**Encoding**:

- `1'b0` = Hold PC (stall)
- `1'b1` = Update PC

**Importance**: ⭐⭐ **IMPORTANT** (but may be handled by control FSM instead)

**Why it matters**:

- Needed to stall PC during AXI memory transactions
- Prevents PC from incrementing during multi-cycle operations

**Alternative approach**:
The control FSM (rv32i_control.sv) could directly manage PC updates based on FSM state, making this decoder signal unnecessary.

**Recommendation**:
❌ **NOT needed in decoder** - This is better handled by the control FSM which knows about AXI stalls and pipeline state.

---

### 3. `pc_src` (Program Counter Source Mux)

**Purpose**: Selects the next PC value

**Encoding** (proposed):

- `2'b00` = PC + 4 (sequential)
- `2'b01` = PC + immediate (branches, JAL)
- `2'b10` = rs1 + immediate (JALR)
- `2'b11` = TRAP_VECTOR (traps)

**Importance**: ⭐⭐⭐ **CRITICAL**

**Why it's critical**:

- Determines control flow for branches and jumps
- Required for implementing branch/jump instructions correctly

**Note**: The EXAMPLE decoder has `pc_src` as 1-bit, but needs to be expanded to 2 bits.

**Instructions that need it**:

- `pc_src = 2'b00`: All non-control-flow instructions
- `pc_src = 2'b01`: JAL, taken branches (BEQ, BNE, BLT, BGE, BLTU, BGEU)
- `pc_src = 2'b10`: JALR
- `pc_src = 2'b11`: Illegal instruction trap (set by control FSM, not decoder)

---

### 4. `result_src` or `wb_src` (Alternative name for mem_to_reg)

**Same as `mem_to_reg`** - just different naming conventions.

Some designs use:

- `mem_to_reg` (emphasizes memory-to-register path)
- `result_src` (more generic, emphasizes result selection)
- `wb_src` (writeback source)

**Recommendation**: Use `mem_to_reg` as it's more descriptive.

---

### 5. `alu_zero` (ALU Zero Output)

**Purpose**: Flag indicating ALU result is zero

**Importance**: ❌ **NOT needed** as separate decoder signal

**Why**:

- This is generated by the ALU itself, not the decoder
- Used internally for some branch implementations
- Since we have a separate branch comparator, not needed

---

### 6. `trap` or `exception` (Trap/Exception Flag)

**Purpose**: Indicates instruction causes a trap

**Importance**: ⭐⭐ **IMPORTANT**

**Overlap with existing signals**:
The EXAMPLE decoder already has `illegal` flag. This covers the main trap case in Phase 1.

**Additional trap sources** (may need signals):

- Misaligned memory access (could be checked by control logic)
- AXI error response (detected during memory stage, not decode)

**Recommendation**:
✅ Current `illegal` signal is sufficient for Phase 1. Control FSM handles other trap conditions.

---

## Summary and Recommendations

### Must Add (Critical)

1. ✅ **`mem_to_reg[1:0]`** - MUST add to decoder
   - Without this, loads and jumps cannot write correct data to registers
   - Affects: LB, LH, LW, LBU, LHU, JAL, JALR (12 instructions)

2. ✅ **`pc_src[1:0]`** - MUST expand from 1-bit to 2-bits
   - Need to distinguish PC+4, PC+imm, rs1+imm
   - Affects: JAL, JALR, all 6 branches (8 instructions)

### Should NOT Add (Handled Elsewhere)

1. ❌ **`pc_wr_en`** - Control FSM handles this based on state
2. ❌ **`alu_zero`** - Generated by ALU or branch comparator
3. ❌ **Additional trap flags** - `illegal` covers Phase 1 needs

---

## Updated Decoder Interface Proposal

```systemverilog
module rv32i_decode (
  // Instruction input
  input  logic [31:0] instruction,

  // Decoded register addresses
  output logic [4:0]  rs1,
  output logic [4:0]  rs2,
  output logic [4:0]  rd,

  // ALU control
  output logic [3:0]  alu_op,
  output logic        alu_src_a,    // 0=rs1, 1=PC
  output logic        alu_src_b,    // 0=rs2, 1=immediate

  // Immediate format
  output logic [2:0]  imm_fmt,

  // Register file control
  output logic        reg_wr_en,

  // Memory control
  output logic        mem_rd,
  output logic        mem_wr,
  output logic [2:0]  mem_size,
  output logic        mem_unsigned,

  // Branch/Jump control
  output logic        branch,
  output logic [2:0]  branch_op,
  output logic        jump,
  output logic        jalr,

  // Writeback and PC control
  output logic [1:0]  mem_to_reg,   // ⭐ NEW: 00=ALU, 01=MEM, 10=PC+4, 11=IMM
  output logic [1:0]  pc_src,       // ⭐ EXPANDED: 00=PC+4, 01=PC+imm, 10=rs1+imm, 11=trap

  // Exception
  output logic        illegal
);
```

---

## Instruction-by-Instruction Control Signal Table

| Instruction | mem_to_reg | pc_src | Notes |
| :---------: | :--------: | :----: | :---: |
| **ALU ops** (ADD, SUB, AND, OR, XOR, SLL, SRL, SRA, SLT, SLTU) | 00 (ALU) | 00 (PC+4) | Standard ALU operation |
| **ALU-imm** (ADDI, ANDI, ORI, XORI, SLLI, SRLI, SRAI, SLTI, SLTIU) | 00 (ALU) | 00 (PC+4) | Standard ALU operation |
| **Loads** (LB, LH, LW, LBU, LHU) | 01 (MEM) | 00 (PC+4) | Write memory data to rd |
| **Stores** (SB, SH, SW) | XX (no wr) | 00 (PC+4) | No register write |
| **Branches** (BEQ, BNE, BLT, BGE, BLTU, BGEU) | XX (no wr) | 01 if taken, 00 if not | Conditional PC update |
| **JAL** | 10 (PC+4) | 01 (PC+imm) | Save return address |
| **JALR** | 10 (PC+4) | 10 (rs1+imm) | Save return address |
| **LUI** | 11 (IMM) or 00 (ALU) | 00 (PC+4) | Depends on implementation |
| **AUIPC** | 00 (ALU) | 00 (PC+4) | ALU computes PC+imm |

---

## Questions for Human Review

1. **LUI implementation**: Should LUI use `mem_to_reg = 11` (pass immediate directly), or `mem_to_reg = 00` (use ALU with special handling)?
   - Option A: ALU has passthrough mode when alu_src_a=0 and alu_op=ADD with rs1=x0
   - Option B: Separate immediate path to writeback mux

2. **AUIPC implementation**: Currently uses ALU with alu_src_a=PC. Is this acceptable?

3. **Trap handling**: Should `pc_src = 11` be set by decoder when `illegal = 1`, or should control FSM override pc_src when handling traps?

4. **Branch not-taken**: When branch is not taken, should decoder output `pc_src = 00`, or should this be decided by control logic combining `branch` and `branch_taken` signals?

---

## Recommendation

**Add these two signals to rv32i_decode.sv**:

1. `mem_to_reg[1:0]` - Critical for loads and jumps
2. Expand `pc_src` to `pc_src[1:0]` - Critical for JALR

Without these, the CPU cannot correctly execute 12 instructions (5 loads + JAL + JALR + potentially LUI).
